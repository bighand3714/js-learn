<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proxy</title>
</head>

<body>
  Proxy: 修改某些操作的默认行为，属于元编程
    在目标对象之前架设一层拦截，外界访问都必须经过一些拦截
    Proxy译为代理器
  Proxy 实例方法
    get(target, propKey, receiver): 拦截对象属性的读取
    set(target, propKey, value, receiver): 拦截对象属性的设置
    has(target, propKey): 拦截 propKey in proxy 的操作，返回一个布尔值
    deleteProperty(target, propKey): 拦截 delete proxy[propKey] 的操作，返回布尔值
    ownKeys(target): 拦截
      Object.getOwnPropertyNames(proxy)、
      Object.getOwnPropertySymbols(proxy)、
      Object.keys(proxy)、
      for...in循环，
        返回一个数组。
        该方法返回目标对象所有自身的属性的属性名，
        Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
    getOwnPropertyDescriptor(target, propKey): 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象
    defineProperty(target, propKey, propDesc): 
      拦截
        Object.defineProperty(proxy, propKey, propDesc）、
        Object.defineProperties(proxy, propDescs)，
          返回一个布尔值
    preventExtensions(target): 拦截Object.preventExtensions(proxy)，返回一个布尔值
    getPrototypeOf(target): 拦截Object.getPrototypeOf(proxy)，返回一个对象
    isExtensible(target): 拦截Object.isExtensible(proxy)，返回一个布尔值
    setPrototypeOf(target, proto): 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值
    apply(target, object, args): 拦截 Proxy 实例作为函数调用的操作，
      比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)
    construct(target, args): 拦截 Proxy 实例作为构造函数调用的操作，
      比如new proxy(...args)
  <script>
    // 重载点运算符
    var obj = new Proxy({}, {
      get: function (target, propKey, receiver) {
        console.log(`getting ${propKey}!`)
        return Reflect.get(target, propKey, receiver)
      },
      set: function (target, propKey, value, receiver) {
        console.log(`setting ${propKey}!`)
        return Reflect.set(target, propKey, value, receiver)
      }
    })
    obj.count = 1
    ++obj.count

    // 作为其他对象的原型对象
    var proxy = new Proxy({}, {
      get: function (target, handler) {
        return 35
      }
    })
    let pro = Object.create(proxy)
    console.log(pro.pro)

    // 拦截器函数
    var handler = {
      get: function (target, name) {
        if (name === 'prototype') {
          return Object.prototype;
        }
        return 'Hello, ' + name;
      },
      apply: function (target, thisBinding, args) {
        return args[0];
      },
      construct: function (target, args) {
        return { value: args[1] };
      }
    };
    var fproxy = new Proxy(function (x, y) {
      return x + y;
    }, handler);
    console.log(
      fproxy(1, 2), // 1
      new fproxy(1, 2), // {value: 2}
      fproxy.prototype === Object.prototype,// true
      fproxy.foo === "Hello, foo" // true
    )

    // get()
    var person = {
      name: 'divel',
    }
    var proxy = new Proxy(person, {
      get: function(target, propKey) {
        if (propKey in target) {
          return target[propKey]
        } else {
          console.log(`throw new ReferenceError(prop name ${propKey} does not exist.)`)
        }
      }
    })

    console.log(proxy.r)
  </script>
</body>

</html>