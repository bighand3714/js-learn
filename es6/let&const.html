<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>let&const</title>
</head>
<body>
  let:
    所声明的变量，只在let命令所在的代码块内有效
      for循环的计数器，就很合适使用let命令。
        for (let i = 0; i < 10; i++)
    不存在变量提升
    暂时性死区: 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
      “暂时性死区”也意味着typeof不再是一个百分之百安全的操作
    不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。
    块级作用域
      块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了
  const:
    const声明一个只读的常量。一旦声明，常量的值就不能改变
    const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动
  顶层对象的属性：浏览器window node global
    ES5：顶层对象的属性与全局变量等价
    let, const, class声明的全局变量不属于顶层对象的属性
    globalThis作为顶层对象
  <script>
    var a = [];
    for (var i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6]();  // 10

    // 当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量
    var a = [];
    for (let i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6](); // 6

    // 暂时性死区
    var tmp = 123;
    if (true) {
      tmp = 'abc'; // ReferenceError
      let tmp;
    }
  </script>
</body>
</html>